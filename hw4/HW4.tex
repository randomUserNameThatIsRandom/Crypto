\documentclass{article}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{blindtext}
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
\title{Crypto - HW 4}
\author{Hagai Ben Yehuda, ID num: 305237000\\ Jonathan Bauch, ID num: 204761233}
\date{}
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}
\interlinepenalty 10000
\begin{document}
  \maketitle

\section{} % 1

\section{} % 2

\section{} % 3

\section{} % 4

\section{} % 5

We will construct $B$ as follows: given number $z=g^{y}$
\begin{enumerate}
\setcounter{enumi}{-1}
\item if z == 1, return $y=0$
\item choose random $r\in\left[1,p-1\right]$
\item calculate $z^{r}=g^{yr}$, $r^{-1}$ (using iterated squaring, and xgcd)
\item run $A\left(z^{r}\right)$
\begin{itemize}
\item if it succeeded and returned $yr$, then return $y$ by multiplying by $r^{-1}$
\item otherwise, return to step 1
\item if failed 1000 times, quit
\end{itemize}
\end{enumerate}
\textbf{Correctness}: As shown in a previous exercise, if $r$ is
uniformly distributed on $\left[1,p-1\right]$ and $y\in\left[1,p-1\right]$
then $ry$ is uniformly distributed on that range. And indeed $y\in\left[1,p-1\right]$
because in step 0 we rule out $y=0$. Therefore there is a $\frac{1}{1000}$
probability that $yr$ is in the exponents that $A$ can successfully
find. Therefore there is a $\frac{1}{1000}$ that step $3$ succeeds.
We then get:
\[
\Pr\left[\mbox{\ensuremath{B} succeeds}\right]=1-\left(\frac{999}{1000}\right)^{1000}\approx0.63>0.5
\]
\textbf{Run time}: step 0 is $O(1)$, choosing $r$ is $O(n)$ when
$n=\log_{2}\left(p\right)$. Calculating $z^{r}$ by repeated squaring
is $O(n^{2})$, and xgcd is $O(n)$. $A$ is poly-time in $n$, therefore it runs in time
$O(n^{k})$ for some $k\ge1$. then we get that a single iteration
of B takes $O(n^{2}+n^{k})$. Since there is a constant number of
iterations, the total runtime is $O(n^{2}+n^{k})=O\left(max\left\{ n^{2},n^{k}\right\} \right)$.

\section{} % 6

\subsection{} % 6.a
\textbf{Decryption}: Given $ \left<c_1, c_2\right> $:
\begin{itemize}
\item Compute $ c_1^x $
\item If $ c_1^x = c_2 $ return 0,
\item Otherwise return 1.
\end{itemize}
\textbf{Run-Time}: it is clear that this method is efficient, as it requires one exponentiation (which can be done efficiently by iterated squaring). \\
\textbf{Correctness}:
\begin{itemize}
\item  If the encrypted message is $ b = 0 $, then $ c_1^x = \left(g^y\right)^x = \left(g^y\right)^x = h^y = c_2 $. Therefore the decryption will succeed with probability 1.
\item If the encrypted message is $ b = 1 $, then $ c_1^x = g^{xy} $, $ c_2 =g^z $. Since $ y $ is random and independent from $ z $, then so is $ yx $. This mean that $ \Pr[yx \equiv z \pmod{p}] = \frac{1}{p} $. Therefore $ \Pr[c_1^x \neq c_2] = 1 - \frac{1}{p} $, meaning that the decryption succeeds with some negligible error probability.
\end{itemize}

\subsection{} % 6.b

\section{} % 7
Let $i \leftarrow U_t$ be the random index $A_1$ chooses. $b \leftarrow U_{0,1}$. $c^i = E_{pk}(m_b^i)$. Denote $A(x)$ the answer of an adversary $A$, given a cipher $x$.
\begin{align*}
\frac{1}{2} + \varepsilon \ge &Pr[\mbox{\ensuremath{A_1} wins}] \\
= &Pr[A_1(c^i)=b] \\
= &\frac{1}{2} \sum_{d \in \{0,1\}} Pr[A_1(c^i)=d \mid b=d] \\
= &\frac{1}{2t} \sum_{d \in \{0,1\}} \sum_{k=1}^t Pr[A_1(c^i)=d \mid b=d \wedge i=k] \\
=  &\frac{1}{2t} \sum_{d \in \{0,1\}} \sum_{k=1}^t Pr[A_1(E_{pk}(m_d^k))=d \mid b=d \wedge i=k] \\
=  &\frac{1}{2t} \sum_{d \in \{0,1\}} \sum_{k=1}^t Pr[A_{mult}(E_{pk}(m_0^1, \ldots, m_0^{k-1}, m_d^k, m_1^{k+1}, \ldots, m_1^t))=d] \\
= &\frac{1}{2t} ( 
  Pr[A_{mult}(E_{pk}(m_0^1, \ldots, m_0^t))=0] + \\
& Pr[A_{mult}(E_{pk}(m_1^1, \ldots, m_1^t))=1] + \\
& \sum_{k=1}^{t-1} \left( Pr[A_{mult}(E_{pk}(m_0^1, \ldots, m_0^k, m_1^{k+1}, \ldots, m_1^t))=0] + Pr[A_{mult}(E_{pk}(m_0^1, \ldots, m_0^k, m_1^{k+1}, \ldots, m_1^t))=1] \right)
 ) \\
= &\frac{1}{2t} ( 
  Pr[A_{mult}(E_{pk}(m_0^1, \ldots, m_0^t))=0] + \\
& Pr[A_{mult}(E_{pk}(m_1^1, \ldots, m_1^t))=1] + \\
& t-1 ) \\
= &\frac{1}{2t} (2 \cdot Pr[\mbox{\ensuremath{A_{mult}} wins}] + t-1) \\
= &\frac{1}{t} Pr[\mbox{\ensuremath{A_{mult}} wins}] + \frac{1}{2} - \frac{1}{2t}
\end{align*}

Therefore:
\begin{align*}
Pr[\mbox{\ensuremath{A_{mult}} wins}] 
\le t(\frac{1}{2} + \varepsilon - \frac{1}{2} + \frac{1}{2t})
= \frac{1}{2} + t \varepsilon
\end{align*}


\section{} % 8

\subsection{} % 8.a
First, note that if $p,q$ are $n$ bit numbers, then $m=pq$ has at most $2n=O(n)$ bits.
Computing $a^{2^t}$ using iterated squaring involves $t$ steps of (modular) squaring a number in the range $[0,m-1]$: \[
a_0=a, a_1=a_0^2=a^2, a_2=a_1^2=a^{2^2}, a_3=a_2^2=a^{2^3}, \ldots, a_t=a_{t-1}^2=a^{2^t}
\]
Therefore the number of modular multiplications of $O(n)$ bit numbers is exactly $t$.

\subsection{} % 8.b
Knowing the factorization of $m$ allows us to compute $\phi(m)=(p-1)(q-1)$. Then, by Euler's theorem we know that $a^{2^t} \equiv a^{2^t \mod{\phi(m)}} \pmod{m}$. Therefore to compute $a^{2^t} \pmod{m}$ we need to calculate: \[
a_0=a, a_1=a_0^2=a^2, \ldots, a_k=a_{k-1}^2=a^{2^k}
\]
where $k$ is the number of bits of $2^t \mod \phi(m)$.
afterwards we multiply the elements according to the binary representation of $\phi(m)$.
$\phi(m)$ can have no more than $2n$ bits, therefore we need to perform at most $k+k = 2k \le 4n$ modular multiplications.
Note that if $2^t < \phi(m)$ then we resort to the first method and perform exactly $t$ multiplication. \\
So to summarize, we perform no more than $\min \{ t, 4n \}$ multiplications.

\end{document}